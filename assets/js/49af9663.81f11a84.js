"use strict";(self.webpackChunknotas_personales=self.webpackChunknotas_personales||[]).push([[9807],{6261:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});var n=r(4848),c=r(8453);const o={title:"Mockito"},s=void 0,t={id:"Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/Mockito",title:"Mockito",description:"Mockito es un framework de pruebas unitarias para Java que permite crear objetos simulados (mocks) de clases y interfaces, estos objetos pueden ser utilizados para simular el comportamiento de objetos reales en pruebas unitarias.",source:"@site/docs/Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/Mockito.md",sourceDirName:"Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas",slug:"/Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/Mockito",permalink:"/notas-de-aprendizaje/docs/Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/Mockito",draft:!1,unlisted:!1,editUrl:"https://github.com/SanRM/notas-de-aprendizaje/edit/main/docs/Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/Mockito.md",tags:[],version:"current",frontMatter:{title:"Mockito"},sidebar:"tutorialSidebar",previous:{title:"JUnit",permalink:"/notas-de-aprendizaje/docs/Lenguajes de programaci\xf3n/Java/Pruebas unitarias/Dependencias/Dependencias para pruebas/JUnit"},next:{title:"Introducci\xf3n a Spring Boot",permalink:"/notas-de-aprendizaje/docs/Lenguajes de programaci\xf3n/Java/Spring Boot/Introducci\xf3n a Spring Boot"}},i={},l=[{value:"Instalaci\xf3n",id:"instalaci\xf3n",level:2},{value:"Ejemplo",id:"ejemplo",level:2},{value:"Test sin Mockito",id:"test-sin-mockito",level:3},{value:"Test con Mockito",id:"test-con-mockito",level:2}];function d(e){const a={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components},{Card:r}=a;return r||function(e,a){throw new Error("Expected "+(a?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Card",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.strong,{children:"Mockito"})," es un framework de pruebas unitarias para Java que permite crear objetos simulados (mocks) de clases y interfaces, estos objetos pueden ser utilizados para simular el comportamiento de objetos reales en pruebas unitarias."]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Mockito trabaja con las dependencias de un objeto, permitiendo simular el comportamiento de estas dependencias."}),"\n"]}),"\n",(0,n.jsxs)(r,{children:[(0,n.jsx)(a.h2,{id:"instalaci\xf3n",children:"Instalaci\xf3n"}),(0,n.jsxs)(a.p,{children:["Para utilizar Mockito en un proyecto Java, es necesario agregar la dependencia correspondiente al archivo ",(0,n.jsx)(a.code,{children:"pom.xml"})," del proyecto."]}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-java",children:"<dependency>\r\n    <groupId>org.mockito</groupId>\r\n    <artifactId>mockito-core</artifactId>\r\n    <version>3.11.2</version>\r\n    <scope>test</scope>\r\n</dependency>\n"})})]}),"\n",(0,n.jsxs)(r,{children:[(0,n.jsx)(a.h2,{id:"ejemplo",children:"Ejemplo"}),(0,n.jsxs)(a.p,{children:["Supongamos que tenemos una clase ",(0,n.jsx)(a.code,{children:"Calculator"})," que realiza operaciones matem\xe1ticas, y una clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," que realiza operaciones matem\xe1ticas utilizando la clase ",(0,n.jsx)(a.code,{children:"Calculator"}),"."]}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-java",children:"public class Calculator {\r\n\r\n    public int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n}\r\n\r\npublic class CalculatorService {\r\n\r\n    private Calculator calculator;\r\n\r\n    public CalculatorService(Calculator calculator) {\r\n        this.calculator = calculator;\r\n    }\r\n\r\n    public int add(int a, int b) {\r\n        return calculator.add(a, b);\r\n    }\r\n\r\n}\n"})}),(0,n.jsxs)(r,{children:[(0,n.jsx)(a.h3,{id:"test-sin-mockito",children:"Test sin Mockito"}),(0,n.jsxs)(a.p,{children:["Para probar la clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," sin Mockito, necesitamos crear una instancia de la clase ",(0,n.jsx)(a.code,{children:"Calculator"})," y pasarla al constructor de ",(0,n.jsx)(a.code,{children:"CalculatorService"}),"."]}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-java",children:"\r\npublic class CalculatorServiceTest {\r\n\r\n    @Test\r\n    public void testAdd() {\r\n\r\n        //Given\r\n        Calculator calculator = new Calculator();\r\n        CalculatorService calculatorService = new CalculatorService(calculator);\r\n\r\n        //When\r\n        int result = calculatorService.add(2, 3);\r\n\r\n        //Then\r\n        assertEquals(5, result);\r\n    }\r\n\r\n}\n"})}),(0,n.jsxs)(a.p,{children:["Este enfoque tiene la desventaja de que estamos probando la clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," junto con la clase ",(0,n.jsx)(a.code,{children:"Calculator"}),", lo cual no es ideal para pruebas unitarias porque estamos probando dos clases a la vez y no podemos aislar la clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," para probarla de forma independiente, adem\xe1s, si la clase ",(0,n.jsx)(a.code,{children:"Calculator"})," tiene dependencias, tambi\xe9n tendr\xedamos que crear instancias de estas dependencias."]})]}),(0,n.jsxs)(r,{children:[(0,n.jsx)(a.h2,{id:"test-con-mockito",children:"Test con Mockito"}),(0,n.jsxs)(a.p,{children:["Para probar la clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," con Mockito, podemos crear un mock de la clase ",(0,n.jsx)(a.code,{children:"Calculator"})," y pasar este mock al constructor de ",(0,n.jsx)(a.code,{children:"CalculatorService"}),"."]}),(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-java",children:"\r\nimport static org.mockito.Mockito.*;\r\n\r\npublic class CalculatorServiceTest {\r\n\r\n    @Test\r\n    public void testAdd() {\r\n        \r\n        //Given\r\n        Calculator calculator = mock(Calculator.class);\r\n        CalculatorService calculatorService = new CalculatorService(calculator);\r\n\r\n        //When\r\n        when(calculator.add(2, 3)).thenReturn(5);\r\n        int result = calculatorService.add(2, 3);\r\n\r\n        //Then\r\n        assertEquals(5, result);\r\n\r\n    }\r\n\r\n}\n"})}),(0,n.jsxs)(a.p,{children:["En este caso, estamos creando un mock de la clase ",(0,n.jsx)(a.code,{children:"Calculator"})," utilizando el m\xe9todo ",(0,n.jsx)(a.code,{children:"mock()"})," de Mockito, luego estamos configurando el comportamiento del mock utilizando el m\xe9todo ",(0,n.jsx)(a.code,{children:"when().thenReturn()"}),", y finalmente estamos pasando el mock al constructor de ",(0,n.jsx)(a.code,{children:"CalculatorService"}),", de esta forma podemos probar la clase ",(0,n.jsx)(a.code,{children:"CalculatorService"})," de forma aislada y sin depender de la clase ",(0,n.jsx)(a.code,{children:"Calculator"}),"."]})]})]})]})}function u(e={}){const{wrapper:a}={...(0,c.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,a,r)=>{r.d(a,{R:()=>s,x:()=>t});var n=r(6540);const c={},o=n.createContext(c);function s(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);