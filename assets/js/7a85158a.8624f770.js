"use strict";(self.webpackChunknotas_personales=self.webpackChunknotas_personales||[]).push([[889],{7778:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>t,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var s=n(4848),r=n(8453),o=n(4317);const i={title:"Normalizaci\xf3n"},l="Normalizaci\xf3n de Bases de Datos",d={id:"Bases de datos/Normalizaci\xf3n",title:"Normalizaci\xf3n",description:"La normalizaci\xf3n de bases de datos es un proceso fundamental en el dise\xf1o de bases de datos relacionales, que busca organizar los datos de manera eficiente y reducir la redundancia. Este proceso ayuda a evitar problemas de inconsistencia y anomal\xedas en los datos, mejorando la integridad y el rendimiento de la base de datos. Las formas normales m\xe1s comunes son la Primera Forma Normal (1NF), la Segunda Forma Normal (2NF) y la Tercera Forma Normal (3NF).",source:"@site/docs/Bases de datos/Normalizaci\xf3n.md",sourceDirName:"Bases de datos",slug:"/Bases de datos/Normalizaci\xf3n",permalink:"/notas-de-aprendizaje/docs/Bases de datos/Normalizaci\xf3n",draft:!1,unlisted:!1,editUrl:"https://github.com/SanRM/notas-de-aprendizaje/edit/main/docs/Bases de datos/Normalizaci\xf3n.md",tags:[],version:"current",frontMatter:{title:"Normalizaci\xf3n"},sidebar:"tutorialSidebar",previous:{title:"Modelo Relacional",permalink:"/notas-de-aprendizaje/docs/Bases de datos/Modelo de datos/modelo-relacional"},next:{title:"Relaciones entre Entidades",permalink:"/notas-de-aprendizaje/docs/Bases de datos/Relaciones-entre-entidades"}},t={},c=[{value:"Primera Forma Normal (1NF)",id:"primera-forma-normal-1nf",level:2},{value:"Pasos para convertir una tabla en 1NF",id:"pasos-para-convertir-una-tabla-en-1nf",level:3},{value:"Segunda Forma Normal (2NF)",id:"segunda-forma-normal-2nf",level:2},{value:"Pasos para convertir una tabla en 2NF",id:"pasos-para-convertir-una-tabla-en-2nf",level:3},{value:"Tercera Forma Normal (3NF)",id:"tercera-forma-normal-3nf",level:2},{value:"Pasos para convertir una tabla en 3NF",id:"pasos-para-convertir-una-tabla-en-3nf",level:3},{value:"Resumen",id:"resumen",level:2}];function m(e){const a={h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"normalizaci\xf3n-de-bases-de-datos",children:"Normalizaci\xf3n de Bases de Datos"}),"\n",(0,s.jsx)(a.p,{children:"La normalizaci\xf3n de bases de datos es un proceso fundamental en el dise\xf1o de bases de datos relacionales, que busca organizar los datos de manera eficiente y reducir la redundancia. Este proceso ayuda a evitar problemas de inconsistencia y anomal\xedas en los datos, mejorando la integridad y el rendimiento de la base de datos. Las formas normales m\xe1s comunes son la Primera Forma Normal (1NF), la Segunda Forma Normal (2NF) y la Tercera Forma Normal (3NF)."}),"\n","\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(a.h2,{id:"primera-forma-normal-1nf",children:"Primera Forma Normal (1NF)"}),(0,s.jsx)(a.p,{children:"Una tabla se considera en Primera Forma Normal (1NF) si no contiene grupos repetitivos de datos y todos los atributos son at\xf3micos, es decir, indivisibles. Cada celda de la tabla debe contener un solo valor y no puede tener m\xfaltiples valores separados por comas u otros delimitadores."}),(0,s.jsx)(a.h3,{id:"pasos-para-convertir-una-tabla-en-1nf",children:"Pasos para convertir una tabla en 1NF"}),(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsx)(a.li,{children:"Eliminar grupos de repetici\xf3n en tablas individuales."}),"\n",(0,s.jsx)(a.li,{children:"Crear una tabla independiente para cada conjunto de datos relacionados."}),"\n",(0,s.jsx)(a.li,{children:"Identificar cada conjunto de datos relacionados con una clave primaria."}),"\n"]}),(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Ejemplo:"})," En un sistema de gesti\xf3n de estudiantes, una tabla que almacena estudiantes y sus cursos debe descomponerse si los cursos est\xe1n almacenados en una sola columna con valores separados por comas. En su lugar, se debe crear una tabla de estudiantes y una tabla de cursos con una relaci\xf3n de uno a muchos."]})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(a.h2,{id:"segunda-forma-normal-2nf",children:"Segunda Forma Normal (2NF)"}),(0,s.jsx)(a.p,{children:"Una tabla est\xe1 en Segunda Forma Normal (2NF) si cumple con los requisitos de 1NF y todos los atributos no clave est\xe1n completamente dependientes de la clave primaria. Esto significa que ning\xfan atributo no clave debe depender parcialmente de la clave primaria."}),(0,s.jsx)(a.h3,{id:"pasos-para-convertir-una-tabla-en-2nf",children:"Pasos para convertir una tabla en 2NF"}),(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsx)(a.li,{children:"Crear tablas independientes para conjuntos de valores que se aplican a varios registros."}),"\n",(0,s.jsx)(a.li,{children:"Relacionar estas tablas con una clave for\xe1nea."}),"\n"]}),(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Ejemplo:"})," En un sistema de gesti\xf3n de pedidos, una tabla que almacena detalles del pedido debe dividirse si algunos atributos dependen solo parcialmente de la clave primaria. Si la clave primaria es la combinaci\xf3n de ID de pedido y ID de producto, pero el nombre del producto solo depende del ID de producto, entonces el nombre del producto debe moverse a una tabla de productos separada."]})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(a.h2,{id:"tercera-forma-normal-3nf",children:"Tercera Forma Normal (3NF)"}),(0,s.jsx)(a.p,{children:"Una tabla est\xe1 en Tercera Forma Normal (3NF) si cumple con los requisitos de 2NF y no hay dependencias transitivas entre los atributos no clave. Esto significa que los atributos no clave deben depender directamente de la clave primaria y no de otros atributos no clave."}),(0,s.jsx)(a.h3,{id:"pasos-para-convertir-una-tabla-en-3nf",children:"Pasos para convertir una tabla en 3NF"}),(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsx)(a.li,{children:"Eliminar los campos que no dependen de la clave."}),"\n"]}),(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Ejemplo:"})," En un sistema de gesti\xf3n de empleados, si una tabla que almacena empleados incluye una columna para el nombre del departamento y una columna para el nombre del gerente del departamento, pero el nombre del gerente depende del nombre del departamento, entonces el nombre del gerente debe moverse a una tabla de departamentos separada."]})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(a.h2,{id:"resumen",children:"Resumen"}),(0,s.jsx)(a.p,{children:"El proceso de normalizaci\xf3n generalmente implica dividir una tabla grande en varias tablas m\xe1s peque\xf1as y relacionadas entre s\xed, minimizando as\xed la redundancia y mejorando la integridad de los datos. Algunas de las ventajas de la normalizaci\xf3n incluyen:"}),(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Reducci\xf3n de la redundancia de datos."}),"\n",(0,s.jsx)(a.li,{children:"Mejora de la integridad de los datos al evitar anomal\xedas de actualizaci\xf3n, inserci\xf3n y eliminaci\xf3n."}),"\n",(0,s.jsx)(a.li,{children:"Mejora del rendimiento de la consulta al tener tablas m\xe1s peque\xf1as y bien estructuradas."}),"\n"]}),(0,s.jsx)(a.p,{children:"Es importante tener en cuenta que la normalizaci\xf3n tambi\xe9n puede llevar a un mayor n\xfamero de joins en las consultas, lo que podr\xeda afectar el rendimiento en algunas situaciones. Por esto, el proceso de normalizaci\xf3n debe equilibrarse con las necesidades espec\xedficas del sistema y las consideraciones de rendimiento."})]})]})}function u(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},4317:(e,a,n)=>{n.d(a,{A:()=>r});n(6540);var s=n(4848);function r(e){let{children:a,height:n="auto"}=e;return(0,s.jsx)("div",{style:{backgroundColor:"var(--ifm-color-emphasis-100)",borderRadius:"5px",height:n,padding:"20px 20px 0px 20px",margin:"20px 0px 20px 0px",border:"1px solid var(--ifm-color-emphasis-200)",color:"var(--ifm-color-emphasis-900)",gap:"20px"},children:a})}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>l});var s=n(6540);const r={},o=s.createContext(r);function i(e){const a=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:a},e.children)}}}]);